#!/usr/bin/env python

from dynamic_reconfigure.parameter_generator_catkin import ParameterGenerator, double_t, int_t, bool_t, str_t

gen = ParameterGenerator()

gen.add("automatic_mode", int_t, 0, "0 - Manual, 1 - Semiautomatic, 2 - Automatic", 0, 0, 2)
gen.add("undock_distance", double_t, 0, "Initial distance to drive back straight for undocking", 2, 0, 100)
gen.add("undock_angled_distance", double_t, 0, "Second stage distance to drive back at angle for undocking", 0, 0, 100)
gen.add("undock_angle", double_t, 0, "Angle to drive back for second stage undocking", 0, -90, 90)
gen.add("undock_fixed_angle", bool_t, 0, "True to fix the undock angle, false to vary it", True)
gen.add("undock_use_curve", bool_t, 0, "True to use a curved second stage, false for a straight second stage", True)
gen.add("docking_distance", double_t, 0, "Distance to drive forward during docking", 2, 0, 100)
gen.add("docking_approach_distance", double_t, 0, "Distance to approach docking point", 1.5, 0, 5)
gen.add("docking_retry_count", int_t, 0, "How often should we retry docking", 4, 0, 50)
gen.add("docking_extra_time", double_t, 0, "Continue docking for extra time (s) to ensure good contact", 0, 0, 1.0)
gen.add("docking_redock", bool_t, 0, "Whether to attempt redocking if the voltage is no longer detected after docking.", False)
gen.add("docking_waiting_time", double_t, 0, "Time to wait (s) before docking", 0, 0, 60)
gen.add("undocking_waiting_time", double_t, 0, "Time to wait (s) before undocking", 0, 0, 60)
gen.add("perimeter_signal",int_t, 0, "Which perimeter signal should be used? 0-None, positive number gives signal number and uses counterclockwise docking, negative numbers use clockwise docking", 0, -2, 2)
gen.add("outline_count", int_t, 0, "Outline count to mow before filling", 3, 0, 255)
gen.add("outline_overlap_count", int_t, 0, "Outlines to overlap with fill", 0, 0, 255)
gen.add("outline_offset", double_t, 0, "Additional outer outline offset, use positive values for safety, negative values to enlarge the area", 0.0, -1.0, 1.0)
gen.add("mow_angle_offset", double_t, 0, "Mowing angle offset", 0, -180, 180)
gen.add("mow_angle_offset_is_absolute", bool_t, 0, "If true then the offset is relative to East, if false then the offset is relative to the auto-detected angle.", False)
gen.add("mow_angle_increment", double_t, 0, "Mowing angle automatic increment. Will be added to the offset every time the entire map is finished", 0, 0, 180)
gen.add("tool_width", double_t, 0, "Width of the mower", 0.14, 0.1, 2)
gen.add("enable_mower", bool_t, 0, "True to enable mow motor", False)
gen.add("manual_pause_mowing", bool_t, 0, "True to disable mowing automatically", False)
gen.add("motor_hot_temperature", double_t, 0, "Motor temperature to pause mowing", 70.0, 20.0, 150.0)
gen.add("motor_cold_temperature", double_t, 0, "Motor temperature to allow mowing", 40.0, 20.0, 150.0)
gen.add("max_position_accuracy", double_t, 0, "We allow driving as long as our position is better than this value (m)", 0.2, 0.01, 1.0)
gen.add("gps_wait_time", double_t, 0, "Time to wait after good GPS fix", 10.0, 0.0, 60.0)
gen.add("gps_timeout", double_t, 0, "Time to allow driving without valid GPS", 10.0, 0.0, 60.0)
gen.add("add_fake_obstacle", bool_t, 0, "True to add a fake obstacle to hopefully help path approach", False)
gen.add("ignore_gps_errors", bool_t, 0, "True to ignore gps errors. USE ONLY FOR SIMULATION!", False)
gen.add("max_first_point_attempts", int_t, 0, "Maximum attempts to reach the first point of the mow path before trimming", 3, 1, 10)
gen.add("max_first_point_trim_attempts", int_t, 0, "After <max_first_point_attempts> we start to trim the path beginning this often", 3, 1, 10)
gen.add("rain_mode", int_t, 0, "0 - Ignore, 1 - Dock, 2 - Dock until dry, 3 - Pause Automatic Mode", 0, 0, 3)
gen.add("rain_delay_minutes", int_t, 0, "Time to wait after rain to resume mowing", 1, 30, 1440)
gen.add("rain_check_seconds", int_t, 0, "Rain must be detected continuosly for this time to trigger rain_mode", 0, 20, 300)
gen.add("cu_rain_threshold", int_t, 0, "Stock-CoverUI limited rain sensor threshold, below which humidity/dryness value get identified as rain. As higher, as more dry. Default to 700", -1)
gen.add("emergency_lift_period", int_t, 0, "Period (ms) for multiple wheels/halls to be lifted/triggered in order to count as emergency. This is to filter uneven ground", -1)
gen.add("emergency_tilt_period", int_t, 0, "Period (ms) for a single wheel/hall to be lifted/triggered in order to count as emergency. This is to filter uneven ground", -1)
gen.add("emergency_input_config", str_t, 0, "Comma separated list of emergency inputs (halls or stop), where each sensor can be configured in one of the following modes '[!]<I>gnore|<U>nused|<S>top|<L>Lift'", "")
gen.add("shutdown_esc_max_pitch", int_t, 0, "Maximum pitch angle (deg) where ESC shutdown is permitted (0 to disable ESC shutdown)", 0, 0, 180)

exit(gen.generate("mower_logic", "mower_logic", "MowerLogic"))
